# generated by fastapi-codegen:
#   filename:  EaaS-openAPI.yaml
#   timestamp: 2025-07-30T08:58:11+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, conint, constr


class EventType(Enum):
    CREATED = 'CREATED'
    UPDATED = 'UPDATED'
    DELETED = 'DELETED'


class CreateInstanceApplicationRequest(BaseModel):
    appOnboardingId: str = Field(
        ...,
        description='Identifier of the onboarding of this Application package. This identifier is allocated by the Southbound Plugin.',
    )
    additionalParams: Optional[Dict[str, Any]] = Field(
        None, description='Additional Params to pass'
    )


class StopInstanceApplicationRequest(BaseModel):
    appInstanceId: str = Field(
        ...,
        description='Identifier of the instance of the Application. This identifier is allocated by the Southbound Plugin.',
    )


class ProblemDetails(BaseModel):
    type: Optional[str] = Field(
        None,
        description='A URI reference according to IETF RFC 3986 [3] that identifies the problem type. It is encouraged that the URI provides human-readable documentation for the problem (e.g. using HTML) when dereferenced. When this member is not present, its value is assumed to be "about:blank".\n',
    )
    title: Optional[str] = Field(
        None,
        description='A short, human-readable summary of the problem type. It should not change from occurrence to occurrence of the problem, except for purposes of localization. If type is given and other than "about:blank", this attribute shall also be provided.\n',
    )
    status: int = Field(
        ...,
        description='The HTTP status code for this occurrence of the problem.',
        examples=[403],
    )
    detail: str = Field(
        ...,
        description='A human-readable explanation specific to this occurrence of the problem.',
    )
    instance: Optional[str] = Field(
        None,
        description='A URI reference that identifies the specific occurrence of the problem. It may yield further information if dereferenced.',
    )
    additionalAttribute: Optional[Dict[str, Any]] = Field(
        None,
        description='Any number of additional attributes, as defined in a specification or by an implementation.',
    )


class Link(BaseModel):
    href: str = Field(
        ...,
        description='URI of another resource referenced from a resource.  Shall be an absolute URI (i.e. a URI that contains {apiRoot}). A string formatted according to IETF RFC 3986\n',
    )


class Checksum(BaseModel):
    algorithm: str = Field(
        ...,
        description='Name of the algorithm used to generate the checksum. The name  matching when processing the attribute value shall be case-insensitive,  for example, "SHA-256" or "sha-256", "SHA-512" or "sha-512"\n',
        examples=['SHA-256'],
    )
    hash: str = Field(..., description='The hexadecimal value of the checksum.')


class AppPackageSoftwareImageInfo(BaseModel):
    id: str = Field(
        ...,
        description='Identifier of the software image. (should match the id in the appDescriptor)',
    )
    name: str = Field(..., description='Name of the software image.')
    provider: str = Field(..., description='Provider of the software image.')
    version: constr(pattern=r'^\d+(?:\.\d+){0,2}$') = Field(
        ..., description='Version of the software image.', examples=[0.1]
    )
    checksum: Checksum
    isEncrypted: bool = Field(
        ...,
        description='Reflects whether the image is encrypte (true) or not (false).\n',
    )


class AppPackageArtifactInfo(BaseModel):
    artifactPath: Optional[str] = Field(
        None,
        description='Path which identifies the artifact and also allows to access a copy of the artifact. For an artifact contained as a file in the Application package, this attribute shall be present, and the value of this attribute shall start with the name of the first segment in the path in the package,  i.e. it shall not be prefixed by path separator characters such as "." and "/".Ã¹\n',
        examples=['foo/bar/m@ster.sh'],
    )
    artifactURI: Optional[str] = Field(
        None,
        description='URI of the artifact as defined in the Application package manifest. Shall be present if the artifact is external to the package and shall be absent otherwise.',
        examples=['https://example.com/m%40ster.sh'],
    )
    checksum: Optional[Checksum] = None
    isEncrypted: Optional[bool] = Field(
        None,
        description='Reflects whether the image is encrypte (true) or not (false).\n',
    )


class CreateAppPkgInfoRequest(BaseModel):
    userDefinedData: Optional[Dict[str, Any]] = Field(
        None, description='User defined data for the Application package.'
    )


class PackageOnboardingState(Enum):
    CREATED = 'CREATED'
    UPLOADING = 'UPLOADING'
    PROCESSING = 'PROCESSING'
    ONBOARDED = 'ONBOARDED'
    ERROR = 'ERROR'


class PackageOperationalState(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class PackageUsageState(Enum):
    NOT_IN_USE = 'NOT_IN_USE'
    IN_USE = 'IN_USE'


class AppPkgInfo(BaseModel):
    id: str = Field(
        ...,
        description='Identifier of the Application package. This identifier is allocated by the EaaS Application Repository.',
        examples=['c10407ac-31f3-4ee9-a51a-ba1171cd4ca1'],
    )
    field_onboardingId: Optional[str] = Field(
        None,
        alias='_onboardingId',
        description='Identifier of the onboarding of this Application package. This identifier is allocated by the Southbound Plugin. It shall be present after the Application package content has been on-boarded and absent otherwise.',
        examples=['c10407ac-31f3-4ee9-a51a-ba1171cd4ca1'],
    )
    appDescriptorId: Optional[str] = Field(
        None,
        description='This identifier, which is managed by the Application provider, identifies the Application package and the Application Descriptor in a globally unique way. It is copied from the Application Descriptor of the on-boarded Application package. It shall be present after the Application package content has been on-boarded and absent otherwise.',
        examples=['664bf8e3-8a01-4b33-b69a-65cc0799d30b'],
    )
    appDescriptorExtInvariantId: Optional[str] = Field(
        None,
        description='Identifies a Application Descriptor in a version independent manner. This attribute is invariant across versions of the Application Descriptor that fulfil certain conditions related to the external connectivity and management of the Application.  It shall be present after the Application package content has been on- boarded if it is included in the Application Descriptor and shall be absent otherwise. If present it is copied from the Application Descriptor of the on-boarded Application package.\n',
        examples=['664bf8e3-8a01-4b33-b69a-65cc0799d30b'],
    )
    appProvider: Optional[str] = Field(
        None,
        description='Provider of the Application package and the Application Descriptor. This information is copied from the Application Descriptor. It shall be present after the Application package content has been on-boarded and absent otherwise.',
        examples=['ExampleProvider'],
    )
    appProductName: Optional[str] = Field(
        None,
        description='Name to identify the Application product. Invariant for the Application product lifetime. This information is copied from the Application Descriptor. It shall be present after the Application package content has been on-boarded and absent otherwise.',
        examples=['busybox by ExampleProvider'],
    )
    appSoftwareVersion: Optional[constr(pattern=r'^\d+(?:\.\d+){0,2}$')] = Field(
        None,
        description='Software version of the Application. This is changed when there is any change to the software included in the Application package. This information is copied from the Application Descriptor. It shall be present after the Application package content has been on-boarded and absent otherwise.',
        examples=['1.2'],
    )
    appDescriptorVersion: Optional[constr(pattern=r'^\d+(?:\.\d+){0,2}$')] = Field(
        None,
        description='The version of the Application Descriptor. This information is copied from the Application Descriptor. It shall be present after the Application package content has been on-boarded and absent otherwise.',
        examples=['1.2'],
    )
    packageOnboardingState: Optional[PackageOnboardingState] = Field(
        None,
        description='Indicates the current onboarding state of the Application package. Typical values include:\n  - CREATED: The package has been created but not yet on-boarded.\n  - ONBOARDED: The package has been successfully on-boarded.\n  - ERROR: An error occurred during the on-boarding process.\n',
    )
    packageOperationalState: Optional[PackageOperationalState] = Field(
        None,
        description='Indicates the operational state of the Application package. Typical values include:\n  - ENABLED: The package is operational.\n  - DISABLED: The package is not operational.\n',
    )
    packageUsageState: Optional[PackageUsageState] = Field(
        None,
        description='Indicates whether the Application package is in use. Typical values include:\n  - NOT_IN_USE: The package is not currently being used.\n  - IN_USE: The package is in active use.\n',
    )
    softwareImages: Optional[List[AppPackageSoftwareImageInfo]] = Field(
        None,
        description='Information about Application package artifacts that are software images. Every local and external software image referenced from the Application Descriptor shall be included. No other artifacts shall be included. This attribute shall not be present before the Application package content is on-boarded. Otherwise, this attribute shall  be present unless it has been requested to be excluded per attribute selector.\n',
    )
    additionalArtifacts: Optional[List[AppPackageArtifactInfo]] = Field(
        None,
        description='Information about Application package artifacts contained in the Application package that are not software images. Every local and external artifact declared in the  manifest shall be included, except the software images and the files that make up the parts of the Application Descriptor (see clause 9.4.4.3.2). Signature files and certificate files are not  considered as artifacts, however, the content of the "Licenses" and "Testing" directories in the Application package is. This attribute shall not be present before the Application package content is on-boarded. Otherwise, this attribute shall be present if the Application package contains additional artifacts.\n',
    )
    appmInfo: Optional[List[str]] = Field(
        None,
        description='Specifies Application Managers compatible with the Application. This information is copied from the Application Descriptor of the on-boarded Application package. It shall be present after the Application package content has been on-boarded and absent otherwise.\n',
    )
    userDefinedData: Optional[Dict[str, Any]] = Field(
        None,
        description='Optional container for additional, user-defined attributes or metadata.',
    )


class CreateExperimentDescriptorInfoRequest(BaseModel):
    userDefinedData: Dict[str, Any] = Field(
        ..., description='Arbitrary user-defined data.'
    )


class ExperimentDescriptorOnboardingState(Enum):
    CREATED = 'CREATED'
    UPLOADING = 'UPLOADING'
    PROCESSING = 'PROCESSING'
    ONBOARDED = 'ONBOARDED'
    ERROR = 'ERROR'


class ExperimentDescriptorOperationalState(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class ExperimentDescriptorUsageState(Enum):
    IN_USE = 'IN_USE'
    NOT_IN_USE = 'NOT_IN_USE'


class ExperimentDescriptorInfo(BaseModel):
    id: str = Field(
        ...,
        description='Identifier of the onboarded individual Experiment descriptor resource.',
    )
    experimentDescriptorId: Optional[str] = Field(
        None,
        description='This identifier, which is allocated by the Experiment Descriptor designer, identifies the Experiment Descriptor in a globally unique way. It is copied from the Experiment Descriptor content and shall be present after the Experiment Descriptor content is on-boarded.\n',
    )
    experimentDescriptorExtInvariantId: Optional[str] = Field(
        None,
        description='Identifies an Experiment Descriptor in a version independent manner. This attribute is invariant across versions of the Experiment Descriptor that fulfil certain conditions related to the external connectivity and management of the Experiment. It shall be present after the Experiment Descriptor content has been on-boarded if it is included in the Experiment Descriptor and shall be absent  otherwise. If present it is copied from the Experiment Descriptor of the  on-boarded content.\n',
    )
    experimentDescriptorName: Optional[str] = Field(
        None,
        description='Name of the onboarded Experiment Descriptor. This information is  copied from the Experiment Descriptor content and shall be present after the Experiment Descriptor content is on-boarded.\n',
    )
    experimentDescriptorVersion: Optional[str] = Field(
        None,
        description='Version of the on-boarded Experiment Descriptor. This information is  copied from the Experiment Descriptor content and shall be present  after the Experiment Descriptor content is on-boarded.\n',
    )
    experimentDescriptorDesigner: Optional[str] = Field(
        None,
        description='Designer of the on-boarded Experiment Descriptor. This information is  copied from the Experiment Descriptor content and shall be present after the Experiment Descriptor content is on-boarded\n',
    )
    experimentDescriptorInvariantId: Optional[str] = Field(
        None,
        description='This identifier, which is allocated by the Experiment Descriptor designer,  identifies an Experiment Descriptor in a version independent manner. This attribute is invariant across versions of Experiment Descriptor with no constraint on the changes across versions. This information is copied from the Experiment Descriptor of the on-boarded content and shall be present after the Experiment Descriptor content is on-boarded.\n',
    )
    appPkgIds: Optional[List[str]] = Field(
        None,
        description='Identifies the Application package for the Application Descriptor referenced by the on-boarded Experiment descriptor resource.\n',
    )
    onboardingFailureDetails: Optional[ProblemDetails] = None
    experimentDescriptorOnboardingState: ExperimentDescriptorOnboardingState = Field(
        ...,
        description='Onboarding state of the individual Experiment descriptor resource.',
    )
    experimentDescriptorOperationalState: ExperimentDescriptorOperationalState = Field(
        ...,
        description='Operational state of the individual Experiment descriptor resource.',
    )
    experimentDescriptorUsageState: ExperimentDescriptorUsageState = Field(
        ..., description='Usage state of the individual Experiment descriptor resource.'
    )
    userDefinedData: Optional[Dict[str, Any]] = Field(
        None, description='Experiment-specific user-defined data.'
    )


class CreateExperimentRequest(BaseModel):
    experimentDescriptorId: str = Field(
        ...,
        description='Identifier of the Experiment Descriptor that defines the Experiment instance to be created.',
    )
    experimentName: str = Field(
        ..., description='Human-readable name of the Experiment instance to be created.'
    )
    experimentDescription: str = Field(
        ...,
        description='Human-readable description of the Experiment instance to be created.',
    )


class ExperimentState(Enum):
    NOT_INSTANTIATED = 'NOT_INSTANTIATED'
    INSTANTIATED = 'INSTANTIATED'


class InstantiationState(Enum):
    NOT_INSTANTIATED = 'NOT_INSTANTIATED'
    INSTANTIATED = 'INSTANTIATED'


class AppInstance(BaseModel):
    id: str = Field(..., description='Identifier of the Application instance')
    appInstanceName: Optional[str] = Field(
        None,
        description='Human readable name of the Application instance. Modifications to this attribute can be requested using the "ModifyAppInfoData" structure.\n',
    )
    appInstanceDescription: Optional[str] = Field(
        None,
        description='Human-readable description of the Application instance. Modifications to this attribute can be requested using the "ModifyAppInfoData" structure.\n',
    )
    appDescriptorId: str = Field(
        ...,
        description='Identifier of the Application Descriptor on which the Application instance is based.\n',
    )
    appProvider: str = Field(
        ...,
        description='Provider of the Application and the Application Descriptor. The value is copied from the Application Descriptor.\n',
    )
    appProductName: str = Field(
        ...,
        description='Name to identify the Application Product. The value is copied from the Application Descriptor.\n',
    )
    appSoftwareVersion: str = Field(
        ...,
        description='Software version of the Application. The value is copied from the Application Descriptor.\n',
    )
    appVersion: str = Field(
        ...,
        description='Identifies the version of the Application Descriptor. The value is copied from the Application Descriptor.\n',
    )
    appPkgId: str = Field(
        ...,
        description='Identifier of information held by the NFVO about the specific Application package  on which the Application is based. This identifier has been allocated by the Eaas Application Repository.\n',
    )
    appConfigurableProperties: Optional[Dict[str, Any]] = Field(
        None,
        description='Additional Application-specific attributes that provide the current values of the configurable properties of the Application instance. These attributes represent values that are stored persistently in the AppInstance structure and that correspond to configuration parameters of the Application instance. Modifying these attributes affects the configuration of the Application instance either directly  (if the Application instance is in INSTANTIATED state at the time of the modification) or as part of the subsequent Application instantiation  operation (if the Application instance is in NOT_INSTANTIATED state at the time of the modification).\n',
    )
    instantiationState: InstantiationState = Field(
        ...,
        description='The instantiation state of the Application. Permitted values:\n  - NOT_INSTANTIATED: The Application instance is terminated or not instantiated.\n  - INSTANTIATED: The Application instance is instantiated.\n',
    )


class CivicAddressElementItem(BaseModel):
    caType: int = Field(
        ...,
        description='Describe the content type of caValue. The value of caType shall comply with section 3.4 of IETF RFC 4776',
    )
    caValue: str = Field(
        ...,
        description='Content of civic address element corresponding to the caType. The format caValue shall comply with section 3.4 of IETF RFC 4776',
    )


class LocationConstraints(BaseModel):
    countryCode: Optional[str] = Field(
        None,
        description='The two-letter ISO 3166 [13] country code in capital letters. Shall be present in case the "area" attribute is absent. May be absent if the "area" attribute is present.\n',
    )
    civicAddressElement: Optional[List[CivicAddressElementItem]] = Field(
        None,
        description='Zero or more elements comprising the civic address. Shall be absent if the "area" attribute is present.',
    )
    area: Optional[str] = Field(
        None,
        description='Geographic area. Shall be absent if the "civicAddressElement" attribute is present. The content of this attribute shall follow the provisions for the "Polygon" geometry object as defined in IETF RFC 7946 [20], for which the "type" member shall be set to the value "Polygon".\n',
    )


class AppLocationConstraint(BaseModel):
    appProfileId: str = Field(
        ...,
        description='Identifier (reference to) of a AppProfile in the Experiment used to manage the lifecycle of the Application instance.',
    )
    locationConstraint: LocationConstraints


class ParamsForApp(BaseModel):
    appProfileId: str = Field(
        ...,
        description='Identifier of the AppProfile applicable to the Application instance to which the additional parameters apply.',
    )
    appInstanceName: Optional[str] = Field(
        None,
        description='Human-readable name of the Application instance to be created.',
    )
    appInstanceDescription: Optional[str] = Field(
        None,
        description='Human-readable description of the Application instance to be created.',
    )
    appConfigurableProperties: Optional[Dict[str, Any]] = Field(
        None,
        description='If present, this attribute provides values for the configurable properties declared in the Application Descriptor. These values will override the default values if default values are also declared in the Application Descriptor. It provides values for the "appConfigurableProperties" input parameter of the Instantiate Application operation.\n',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='If present, this attribute provides values for metadata Metadata can but need not be declared in the Application Descriptor. These values will override the default values if default values are also declared in the Application Descriptor\n',
    )
    additionalParams: Optional[Dict[str, Any]] = Field(
        None,
        description='Additional input parameters for the instantiation process, specific to the Application being instantiated, as declared in the Application Descriptor as part of "InstantiateAppOpConfig"\n',
    )


class InstantiateExperimentRequest(BaseModel):
    experimentFlavourId: str = Field(
        ...,
        description='Identifier of the Experiment deployment flavour to be instantiated.',
    )
    locationConstraints: Optional[List[AppLocationConstraint]] = Field(
        None,
        description='Defines the location constraints for the Application to be instantiated as part of the Experiment instantiation. An example can be a constraint for the Application to be in a specific geographic location.\n',
    )
    additionalParamsForExperiment: Optional[Dict[str, Any]] = Field(
        None,
        description='Allows to provide additional parameter(s) at the composite Experiment level (as opposed to the Application level, which is covered in additionalParamsForApp), and as opposed to the nested Experiment level, which is covered in additionalParamsForNestedExperiment.\n',
    )
    additionalParamsForApp: Optional[List[ParamsForApp]] = Field(
        None,
        description='Allows to provide additional parameter(s) per Application instance (as opposed to the composite Experiment level, which  is covered in additionalParamsForExperiment), and as opposed to the nested Experiment level, which is covered in  additionalParamsForNestedExperiment). This is for Applications that are to be created by the Orchestrator as part of the Experiment  instantiation and not for existing Application that are referenced for reuse.\n',
    )
    experimentInstantiationLevelId: Optional[str] = Field(
        None,
        description='Identifies one of the Experiment instantiation levels declared in the DF applicable to this Experiment instance.',
    )


class TerminationType(Enum):
    FORCEFUL = 'FORCEFUL'
    GRACEFUL = 'GRACEFUL'


class TerminateAppData(BaseModel):
    appInstanceId: str = Field(
        ...,
        description='Identifies the Application instance, part of the Experiment, to be terminated.',
    )
    terminationType: Optional[TerminationType] = Field(
        None,
        description='Indicates whether forceful or graceful termination is requested.',
    )
    gracefulTerminationTimeout: Optional[int] = Field(
        None,
        description='The attribute is only applicable in case of graceful termination. It defines the time to wait for the Application to be taken out of service  before shutting down the Application and releasing the resources. The unit is seconds.\n',
    )
    additionalParams: Optional[Dict[str, Any]] = Field(
        None,
        description='Additional parameters passed by the OSS/BSS as input to the termination process, specific to the VNF being terminated. (e.g. input parameters to Application-specific termination procedures.)\n',
    )


class TerminationExperimentData(BaseModel):
    additionalParamsForExperiment: Optional[Dict[str, Any]] = Field(
        None,
        description='Allows to provide additional parameter(s) to the termination process at the Experiment level.',
    )


class TerminateExperimentRequest(BaseModel):
    terminationExperimentData: Optional[TerminationExperimentData] = Field(
        None,
        description='Provides additional parameters to the termination process at the Experiment level',
    )
    terminationAppData: Optional[List[TerminateAppData]] = Field(
        None,
        description='Provides the information to terminate Application instance(s).',
    )


class SwImageDesc(BaseModel):
    id: str = Field(..., description='The identifier of this software image.')
    name: str = Field(..., description='The name of this software image.')
    version: str = Field(..., description='The version of this software image.')
    checksum: Optional[Checksum] = None
    swImage: str = Field(
        ...,
        description='This is a reference to the actual software root of the Application Package or can be a URL.\n',
    )
    supportedVirtualisationEnviroment: Optional[List[str]] = Field(
        None,
        description='Specifies the virtualisation environments (e.g. hypervisor) compatible with this software image.',
    )


class LogicalNodeRequirements(BaseModel):
    id: str = Field(
        ..., description='Identifies this set of logical node requirements.'
    )
    logicalNodeRequirementDetail: List[Dict[str, Any]] = Field(
        ...,
        description='The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements.\n',
        min_length=1,
    )


class RequestedAdditionalCapabilityData(BaseModel):
    requestedAdditionalCapability: str = Field(
        ..., description='Specifies a requested additional capability for the VDU.'
    )
    supportMandatory: bool = Field(
        ...,
        description='Indicates whether the requested additional capability is mandatory for successful operation.',
    )
    minRequestedAdditionalCapabilityVersion: Optional[str] = Field(
        None,
        description='Specifies the minimum version of the requested additional capability.',
    )
    preferredRequestedAdditionalCapabilityVersion: Optional[str] = Field(
        None,
        description='Specifies the preferred version of the requested additional capability.',
    )
    targetPerformanceParameters: Dict[str, Any] = Field(
        ...,
        description='Specifies specific attributes, dependent on the requested additional capability type.',
    )


class VirtualCpuPinningPolicy(Enum):
    STATIC = 'STATIC'
    DYNAMIC = 'DYNAMIC'


class VirtualCpuPinningData(BaseModel):
    virtualCpuPinningPolicy: Optional[VirtualCpuPinningPolicy] = Field(
        None,
        description='Indicates the policy for CPU pinning. VALUES: - STATIC - DYNAMIC In case of "STATIC" the virtual CPU cores are requested to be allocated to logical CPU cores according to the rules defined in virtualCpuPinningRules. In case of "DYNAMIC" the allocation of virtual CPU cores to logical CPU cores is decided by the VIM or CISM (e.g. SMT (Simultaneous Multi-Threading) requirements).\n',
    )
    virtualCpuPinningRule: Optional[List] = Field(
        None,
        description='List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of "STATIC" virtualCpuPinningPolicy.\n',
    )


class VirtualCpuData(BaseModel):
    cpuArchitecture: Optional[str] = Field(
        None,
        description='CPU architecture type. Examples are x86, ARM. The cardinality can be 0 during the allocation request,  if no particular CPU architecture type is requested.\n',
    )
    numVirtualCpu: int = Field(..., description='Number of virtual CPUs.')
    virtualCpuClock: Optional[float] = Field(
        None,
        description='Minimum virtual CPU clock rate (e.g. in MHz). The cardinality can be 0 during the allocation request, if no particular value is requested.',
    )
    numVirtualCpuValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Indicates valid values for the number of virtual CPUs. If this attribute is present, the number of virtual CPUs can be indicated in a Application LCM operation. If no value is indicated in the Application LCM operation, the virtual compute resource is instantiated with the value  indicated in the numVirtualCpu attribute. If this attribute is not present, the number of virtual CPUs is not configurable via the Application LCM interface and is always equal to the value indicated in the numVirtualCpu attribute.\n',
    )
    virtualCpuOversubscriptionPolicy: Optional[Dict[str, Any]] = Field(
        None,
        description='The CPU core oversubscription policy e.g. the relation of virtual CPU cores to physical CPU cores/threads. The cardinality  can be 0 during the allocation request, if no particular value is requested\n',
    )
    vduCpuRequirements: Optional[List] = Field(
        None,
        description='Array of key-value pair requirements on the Compute (CPU) for the VDU.',
    )
    virtualCpuPinning: Optional[VirtualCpuPinningData] = None


class VirtualMemoryData(BaseModel):
    virtualMemSize: float = Field(
        ..., description='Amount of virtual Memory (e.g. in MB).'
    )
    virtualMemSizeValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Indicates valid values for the amount of virtual memory. If this attribute is present, the amount of virtual memory can be indicated in a Application LCM operation. If no value is indicated in the Application LCM operation, the virtual compute resource is instantiated with the  value indicated in the virtualMemSize attribute. If this attribute is not present, the amount of virtual memory is not configurable via the Application LCM interface and is always equal to  the value indicated in the virtualMemSize attribute.\n',
    )
    virtualMemOversubscriptionPolicy: Optional[Dict[str, Any]] = Field(
        None,
        description='The memory core oversubscription policy in terms of virtual memory to physical memory on the platform. The cardinality can be  during the allocation request, if no particular value is requested.\n',
    )
    vduMemRequirements: Optional[List] = Field(
        None,
        description='Array of key-value pair requirements on the memory for the VDU.',
    )
    numaEnabled: Optional[bool] = Field(
        None,
        description='It specifies the memory allocation to be cognisant of the relevant process/core allocation. The cardinality can be during the allocation request, if no particular value is requested.\n',
    )
    hugePagesRequirements: Optional[Dict[str, Any]] = Field(
        None,
        description='Specifies requirements on the huge pages resources for the virtual memory.',
    )
    hugePagesRequirementsValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Indicates, for page sizes indicated in the hugePagesRequirements attribute, the valid values of the aggregated size. If this attribute is present for a particular page size, the aggregated memory amount for that page size can be indicated in a  Application LCM operation. If no value is indicated in the Application LCM operation, the aggregated memory amount for that page size is set to the value indicated in hugePagesRequirements attribute.\n',
    )


class BlockStorageData(BaseModel):
    sizeOfStorage: float = Field(
        ..., description='Size of virtualised storage resource in GB.'
    )
    sizeOfStorageValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Indicates valid values for the size of the virtualised storage resource. If this attribute is present, the size of the virtualised storage resource can be indicated in a Application LCM operation.  If no value is indicated in the Application LCM operation, the block storage resource is instantiated with the value indicated in the sizeOfStorage attribute. If this attribute is not present, the size of the virtualised storage resource is not configurable via the Application LCM interface and is always equal to the value indicated in the sizeOfStorage attribute.\n',
    )
    vduStorageRequirements: Optional[List] = Field(
        None,
        description='An array of key-value pairs that articulate the storage deployment requirements.',
    )
    rdmaEnabled: Optional[bool] = Field(
        None, description='Indicate if the storage support RDMA.'
    )
    swImageDesc: Optional[SwImageDesc] = None


class VirtualComputeDesc(BaseModel):
    virtualComputeDescId: str = Field(
        ...,
        description='Unique identifier of this VirtualComputeDesc in the Application Descriptor.',
    )
    logicalNode: Optional[List[LogicalNodeRequirements]] = Field(
        None, description='The logical node requirements.'
    )
    requestAdditionalCapabilities: Optional[List[RequestedAdditionalCapabilityData]] = (
        Field(
            None,
            description='Specifies requirements for additional capabilities. These may be for a range of purposes. One example is acceleration related capabilities.\n',
        )
    )
    computeRequirements: Optional[List] = Field(
        None, description='Specifies compute requirements.'
    )
    virtualMemory: VirtualMemoryData
    virtualCpu: VirtualCpuData
    virtualDisk: Optional[List[BlockStorageData]] = Field(
        None, description='The local or ephemeral disk(s) of the virtualised compute.'
    )


class MonitoringTypeEnum(Enum):
    VIM_CISM = 'VIM_CISM'
    EXTERNAL = 'EXTERNAL'
    PAAS = 'PAAS'


class MonitoringParameter(BaseModel):
    monitoringParameterId: str = Field(
        ..., description='Unique identifier of the monitoring parameter.'
    )
    name: Optional[str] = Field(
        None, description='Human readable name of the monitoring parameter.'
    )
    performanceMetric: str = Field(
        ..., description='Specifies the virtualised resource performance metric.'
    )
    collectionPeriod: Optional[Dict[str, Any]] = Field(
        None,
        description='An attribute that describes the periodicity at which to collect the performance information.',
    )
    monitoringType: Optional[List[MonitoringTypeEnum]] = Field(
        None, description='array of monitoringType Enums (VIM_CISM, EXTERNAL, PAAS)'
    )


class OsContainerDesc(BaseModel):
    osContainerDescId: str = Field(
        ...,
        description='Unique identifier of this OsContainerDesc in the Application Descriptor.',
    )
    name: str = Field(..., description='Human readable name of this OS container.')
    description: str = Field(
        ..., description='Human readable description of this OS container.'
    )
    requestedCpuResources: Optional[int] = Field(
        None,
        description='Number of CPU resources requested for the container (e.g. in milli-CPU-s).',
    )
    requestedCpuValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Indicates valid values for the number of CPU resources requested for the container (e.g. in milli-CPU-s). If this attribute is present, the number of CPU resources requested for the container can be indicated in a Application LCM operation. If no value is indicated in the Application LCM operation, the set of co-located container compute resources is instantiated with the value indicated in the requestedCpuResources attribute. If this attribute is not present, the number of CPU resources requested for the container is not configurable via the Application LCM interface and it is set to the value indicated in the requestedCpuResources attribute if this attribute is present.\n',
    )
    requestedMemoryResource: Optional[float] = Field(
        None,
        description='Amount of memory resources requested for the container (e.g. in MB).',
    )
    requestedMemoryResourcesValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Indicates valid values for the amount of memory resources requested for the container (e.g. in MB). If this attribute is present, the amount of memory resources requested for the container can be indicated in a Application LCM operation. If no value is indicated in the Application LCM operation, the set of co-located container compute resources is instantiated with the value indicated in the requestedMemoryResources attribute. If this attribute is not present, the amount of memory resources requested for the container is not configurable via the Application LCM interface and it is set to the value indicated in the requestedMemoryResources attribute if this attribute is present.\n',
    )
    requestedEphemeralStorageResources: Optional[float] = Field(
        None,
        description='Size of ephemeral storage resources requested for the container (e.g. in GB).',
    )
    requestedEphemeralStorageResourcesValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Indicates valid values for the size of ephemeral storage resources requested for the container (e.g. in GB). If this attribute is present, the amount of ephemeral storage resources requested for the container can be indicated in a Application LCM operation. If no value is indicated in the Application LCM operation, the set of co-located container compute resources is instantiated with the value indicated in the requestedEphemeralStorageResources attribute. If this attribute is not present, the amount of ephemeral storage resources requested for the container is not configurable via the Application LCM interface and it is set to the value indicated in the requestedEphemeralStorageResources attribute if this attribute is present.\n',
    )
    extendedResourceRequests: Optional[List] = Field(
        None,
        description='An array of key-value pairs of extended resources required by the container.',
    )
    extendedResourceRequestsValidValues: Optional[List] = Field(
        None,
        description='For each of the extended resources indicated in the extendedResourceRequests attribute indicates the valid amount values. If this attribute is present for a particular extended resource, the amount of that extended resource requested for the container can be indicated in a Application LCM operation. If no value is indicated in the Application LCM operation, the set of co-located container compute resources is instantiated with the value indicated in the extendedResourceRequests attribute. If this attribute is not present for a particular extended resource, the amount of that extended resource requested for the container is not configurable via the Application LCM interface and is always equal to the value indicated in the extendedResourceRequests attribute.\n',
    )
    cpuResourceLimit: Optional[int] = Field(
        None,
        description='Number of CPU resources the container can maximally use (e.g. in milli-CPU).',
    )
    cpuResourceLimitValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Same as requestedCpuResourcesValidValues, but it will apply to cpuResourceLimit.',
    )
    memoryResourceLimit: Optional[float] = Field(
        None,
        description='Amount of memory resources requested for the container (e.g. in MB).',
    )
    memoryResourceLimitValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Same as requestedMemoryResourcesValidValues, but it will apply to memoryResourceLimit.',
    )
    ephemeralStorageResourceLimit: Optional[float] = Field(
        None,
        description='Size of ephemeral storage resources the container can maximally use (e.g. in GB).',
    )
    ephemeralStorageResourceLimitValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Same as requestedEphemeralStorageResourcesValidValues, but it will apply to ephemeralStorageResourceLimit.',
    )
    hugePageResources: Optional[Dict[str, Any]] = Field(
        None,
        description='Specifies HugePages resources requested for the container, which the container can maximally use (e.g. "hugepages-2Mi: 100Mi").\n',
    )
    hugePageResourcesValidValues: Optional[Dict[str, Any]] = Field(
        None,
        description='Indicates, for page sizes indicated in the hugePageResources attribute, the valid values of the aggregated size that the  container can maximally use. If this attribute is present for a particular page size, the aggregated memory amount that the container can maximally use for that page size can be indicated in a Application LCM operation. If no value is indicated in the Application LCM operation,  the set of co-located container compute resources is instantiated allowing the container to maximally use the value indicated in hugePageResources attribute. If this attribute is not present for a particular page size, the aggregated memory amount that the container can maximally use for that  page size is not configurable via the Application LCM interface and is always equal to the value indicated in the hugePageResources attribute.\n',
    )
    cpuPinningRequirements: Optional[VirtualCpuPinningData] = None
    swImageDesc: SwImageDesc
    bootData: Optional[Dict[str, Any]] = Field(
        None,
        description='Contains a string or a URL to a file contained in the Application package used to customize a container resource at boot time. The bootData may contain variable parts that are replaced by deployment specific values before being sent.\n',
    )
    monitoringParameters: Optional[List[MonitoringParameter]] = Field(
        None,
        description='Specifies the virtualised resource related performance metrics on the OsContainerDesc level to be tracked by the Application Manager.',
    )


class VduProfile(BaseModel):
    vduId: str = Field(..., description='Uniquely references a VDU.')
    minNumberOfInstances: conint(ge=0) = Field(
        ...,
        description='Minimum number of instances of the Application Component based on this VDU that is permitted to exist for this flavour. Shall be zero or greater.\n',
    )
    maxNumberOfInstances: conint(ge=1) = Field(
        ...,
        description='Maximum number of instances of the Application Component based on this VDU that is permitted to exist for this flavour. Shall be greater than zero.\n',
    )


class VduLevel(BaseModel):
    vduId: str = Field(..., description='Uniquely references a VDU.')
    numberOfInstances: conint(ge=0) = Field(
        ...,
        description='Number of instances of Application Component based on this VDU to deploy for an instantiation level or for a scaling delta. Shall be zero or greater.',
    )


class InstantiateAppOpConfig(BaseModel):
    parameter: Optional[List] = Field(
        None,
        description='Array of KVP requirements for Application-specific parameters to be passed when invoking the InstantiateApp operation.',
    )
    targetScaleLevelsSupported: Optional[bool] = Field(
        None,
        description='Signals whether target scale levels are supported by this Application during instantiation. Default is FALSE, i.e. "not supported".\n',
    )


class MciopProfile(BaseModel):
    mciopId: str = Field(
        ..., description='Identifies the MCIOP in the Application package.'
    )
    associatedVdu: Optional[List[str]] = Field(
        None,
        description='List of VDUs which are associated to this MCIOP and which are deployed using this MCIOP. If the referenced VDUs belong to a deployable module, all the referenced VDUs shall belong to that deployable module\n',
    )


class AppExtCpd(BaseModel):
    virtualCpd: str = Field(
        ...,
        description='References the Virtual CPD which is used VirtualCpd) to describe a virtual connection point allowing to access a set of Application Component  instances (based on their respective VDUs).\n',
    )


class LayerProtocolEnum(Enum):
    Ethernet = 'Ethernet'
    MPLS = 'MPLS'
    ODU2 = 'ODU2'
    IPV4 = 'IPV4'
    IPV6 = 'IPV6'
    Pseudo_Wire = 'Pseudo-Wire'
    others = 'others'


class Protocol(Enum):
    TCP = 'TCP'
    UDP = 'UDP'
    SCTP = 'SCTP'


class ServicePortData(BaseModel):
    name: str = Field(..., description='The name of the port exposed by the CP.')
    protocol: Protocol = Field(
        ...,
        description='The L4 protocol for this port exposed by the CP. VALUES: - TCP - UDP - SCTP\n',
    )
    port: int = Field(..., description='The L4 port number exposed by the CP.')
    portConfigurable: bool = Field(
        ...,
        description='Specifies whether the port attribute value is allowed to be configurable.',
    )


class AppProfile(BaseModel):
    appProfileId: str = Field(
        ...,
        description='Identifier of this AppProfile information element. It uniquely identifies a AppProfile.',
    )
    appDescriptorId: str = Field(
        ..., description='References a Application Descriptor.'
    )
    appDescriptorExtInvariantId: str = Field(
        ...,
        description='Identifies a Application Descriptor in a version independent manner. If present it shall have the same value as the  appDescriptorExtInvariantId in the Application Descriptor referenced by the appDescriptorId attribute. It allows for Application instances  during Experiment LCM the use of a Application Descriptor different from the one referenced by the appDescriptorId attribute,  provided they have the same appDescriptorExtInvariantId.\n',
    )
    flavourId: str = Field(
        ..., description='References a flavour within the Application Descriptor.'
    )
    instantiationLevel: Optional[str] = Field(
        None,
        description='Identifier of the instantiation level of the Application DF to be used for instantiation.',
    )
    minNumberOfInstances: int = Field(
        ...,
        description='Minimum number of instances of the Application based on this Application Descriptor that is permitted to exist for this AppProfile.\n',
    )
    maxNumberOfInstances: int = Field(
        ...,
        description='Maximum number of instances of the Application based on this Application Descriptor that is permitted to exist for this AppProfile.',
    )


class AppToLevelMapping(BaseModel):
    appProfileId: str = Field(
        ...,
        description='References the profile to be used for a Application involved in an Experiment level.',
    )
    numberOfInstances: int = Field(
        ...,
        description='Specifies the number of Application instances required for an Experiment level.',
    )


class ExperimentLevel(BaseModel):
    experimentLevelId: str = Field(
        ...,
        description='Identifier of this ExperimentLevel information element. It uniquely identifies an Experiment level within the DF.',
    )
    description: str = Field(
        ..., description='Human readable description of the Experiment level.'
    )
    appToLevelMapping: List[AppToLevelMapping] = Field(
        ...,
        description='Specifies the profile of the Applications involved in this Experiment level and, for each of them, the required number of instances.',
        min_length=1,
    )


class ExperimentDf(BaseModel):
    experimentDfId: str = Field(
        ...,
        description='Identifies this ExperimentDf information element. It identifies an Experiment DF within the Experiment Descriptor.',
    )
    flavourKey: str = Field(
        ...,
        description='Assurance parameter against which this flavour is being described. The key can be a combination of multiple assurance parameters with a logical relationship between them. The parameters should be present as a monitoredInfo attribute in this ExperimentDf.\n',
    )
    appProfile: List[AppProfile] = Field(
        ...,
        description='Application profile to be used for the Experiment flavour.',
        min_length=1,
    )
    nsInstantiationLevel: List[ExperimentLevel] = Field(
        ..., description='Describes the details of an Experiment level.', min_length=1
    )


class SecurityParameters(BaseModel):
    signature: str = Field(
        ..., description='Provides the signature of the signed part of the descriptor.'
    )
    algorithm: str = Field(
        ..., description='Specifies the algorithm used to compute the signature.'
    )
    certificate: Optional[Dict[str, Any]] = Field(
        None,
        description='Provides a certificate or a reference to a certificate to validate the signature. Cardinality of 0 corresponds to the case where the certificate is provided by means outside the Experiment Descriptor.\n',
    )


class ExperimentDescriptor(BaseModel):
    experimentDescriptorIdentifier: str = Field(
        ...,
        description='Identifier of this Experiment Descriptor information element. It Globally uniquely identifies an instance of the Experiment Descriptor.',
    )
    designer: str = Field(
        ..., description='Specifies the designer of the Experiment Descriptor.'
    )
    version: str = Field(
        ..., description='Specifies the version of the Experiment Descriptor.'
    )
    experimentDescriptorName: str = Field(
        ...,
        description='Provides the human readable name of the Experiment Descriptor.',
    )
    experimentDescriptorInvariantId: str = Field(
        ...,
        description='Identifies an Experiment Descriptor in a version independent manner. This attribute is invariant across versions of Experiment Descriptor with  no constraint on the changes across versions.\n',
    )
    experimentDescriptorExtInvariantId: str = Field(
        ...,
        description='Identifies an Experiment Descriptor in a version independent manner. This attribute is invariant across versions of the Experiment Descriptor that fulfil certain conditions related to the external connectivity and management of the Experiment.\n',
    )
    appId: Optional[List[str]] = Field(
        None,
        description='References the Application Descriptor of a constituent Application',
    )
    experimentDf: List[ExperimentDf] = Field(
        ...,
        description='Specifies a DF within the scope of an Experiment Descriptor',
        min_length=1,
    )
    security: SecurityParameters


class AppPackagesGetResponse(RootModel[List[AppPkgInfo]]):
    root: List[AppPkgInfo]


class Payload(BaseModel):
    AppPkg: Optional[AppPkgInfo] = None


class AppPkgEvent(BaseModel):
    AppPkgId: str = Field(..., description='the id this event is referring to')
    EventType_1: EventType = Field(..., alias='EventType', description='event type')
    EventVersion: int = Field(..., description='version of this event')
    Timestamp: int = Field(..., description='Unix time')
    Payload_1: Optional[Payload] = Field(
        None, alias='Payload', description='Event payload'
    )


class ExperimentInstance(BaseModel):
    id: str = Field(..., description='Identifier of the Experiment instance')
    experimentInstanceName: str = Field(
        ..., description='Human readable name of the Experiment instance.'
    )
    experimentDescriptorId: str = Field(
        ...,
        description='Identifier of the Experiment Descriptor on which the Experiment instance is based.\n',
    )
    experimentDescriptorInfoId: str = Field(
        ...,
        description='Identifier of the Experiment Descriptor information object on which the Experiment instance is based. This identifier has been allocated by the EaaS Lifecycle Manager.\n',
    )
    flavourId: Optional[str] = Field(
        None,
        description='Identifier of the Experiment deployment flavour applied to the Experiment instance. This attribute shall be present  if the experimentState attribute value is INSTANTIATED.\n',
    )
    appInstance: Optional[List[AppInstance]] = Field(
        None,
        description='Information on constituent Application(s) of the Experiment instance.',
    )
    experimentState: ExperimentState = Field(
        ...,
        description='The instantiation state of the Experiment. Permitted values:\n  - NOT_INSTANTIATED: The Experiment instance is terminated or not instantiated.\n  - INSTANTIATED: The Experiment instance is instantiated.\n',
    )


class VDU(BaseModel):
    vduId: str = Field(
        ..., description='Unique identifier of this Vdu in Application Descriptor.'
    )
    name: str = Field(..., description='Human readable name of the Vdu.')
    description: str = Field(..., description='Human readable description of the Vdu.')
    mcioIdentificationData: Optional[str] = Field(
        None,
        description='Name and type of the MCIO that realizes this VDU. It allows the Application Manager to identify the MCIO e.g. when querying the CISM. It shall be present when the VDU is realized by one or a set of OS containers and shall be absent otherwise.\n',
    )
    osContainerDesc: Optional[List[OsContainerDesc]] = Field(
        None,
        description='Describes CPU, memory requirements and limits, and software images of the OS Containers realizing this Vdu corresponding to OS Containers sharing the same host and same network namespace. Each unique identifier is referenced only once within one VDU.\n',
    )
    swImageDesc: Optional[SwImageDesc] = None
    virtualComputeDesc: Optional[VirtualComputeDesc] = None


class IstantiationLevel(BaseModel):
    levelId: str = Field(..., description='Uniquely identifies a level within the DF.')
    description: str = Field(
        ..., description='Human readable description of the level.'
    )
    vduLevel: List[VduLevel] = Field(
        ...,
        description='Indicates the number of instances of this VDU to deploy for this level.',
        min_length=1,
    )


class AppLcmOperationsConfiguration(BaseModel):
    instantiateAppOpConfig: Optional[InstantiateAppOpConfig] = None


class AdditionalServiceData(BaseModel):
    portData: List[ServicePortData] = Field(
        ..., description='Service port numbers exposed by the CP.', min_length=1
    )
    serviceData: Optional[Dict[str, Any]] = Field(
        None, description='Service matching information exposed by the CP.'
    )


class DeploymentFlavour(BaseModel):
    flavourId: str = Field(
        ..., description='Identifier of this DF within the Application Descriptor.'
    )
    description: Optional[str] = Field(
        None, description='Human readable description of the DF.'
    )
    vduProfile: Optional[List[VduProfile]] = Field(
        None,
        description='Describes additional instantiation data for the VDUs used in this flavour.',
        min_length=1,
    )
    istantiationLevel: Optional[List[IstantiationLevel]] = Field(
        None,
        description='Describes the various levels of resources that can be used to instantiate the Application using this flavour. Examples: Small, Medium, Large. If there is only one "instantiationLevel" entry, it shall be treated as the default instantiation level for this DF.\n',
        min_length=1,
    )
    appLcmOperationsConfiguration: Optional[AppLcmOperationsConfiguration] = None
    mciopProfile: Optional[List[MciopProfile]] = Field(
        None,
        description='Describes additional instantiation data for the MCIOPs used in this deployment flavour. This attribute shall be present if the  DF references (via the vduProfile) containerized workloads based on a MCIOP.\n',
    )


class VirtualCpd(BaseModel):
    cpdId: str = Field(..., description='Identifier of this Cpd information element.')
    layerProtocol: List[LayerProtocolEnum] = Field(
        ...,
        description='Specifies which protocol the CP uses for connectivity purposes.',
        min_length=1,
    )
    description: Optional[str] = Field(
        None,
        description='Provides human-readable information on the purpose of the CP (e.g. CP for control plane traffic).',
    )
    vdu: List[str] = Field(
        ...,
        description='References the VDU(s) which implement this service.',
        min_length=1,
    )
    additionalServiceData: Optional[List[AdditionalServiceData]] = Field(
        None,
        description='Additional service identification data of the VirtualCp exposed to NFV-MANO.',
    )


class AppDescriptor(BaseModel):
    appDescriptorId: str = Field(
        ...,
        description='Identifier of this Application descriptor information element. This attribute shall be globally unique. The format will be defined in the data model specification phase.\n',
    )
    appDescriptorExtInvariantId: str = Field(
        ...,
        description='Identifies a Application Descriptor in a version independent manner. This attribute is invariant across versions of the Application Descriptor that fulfil certain conditions related to the external connectivity and management of the Application.\n',
    )
    appProvider: str = Field(
        ..., description='Provider of the Application and of the Application Descriptor'
    )
    appProductName: str = Field(
        ...,
        description='Name to identify the Application Product. Invariant for the Application Product lifetime.',
    )
    appSoftwareVersion: str = Field(
        ...,
        description='Software version of the Application. This is changed when there is any change to the software that is included in the Application Package.\n',
    )
    appDescriptorVersion: str = Field(
        ..., description='Specifies the version of the Application Descriptor'
    )
    appmInfo: Optional[List[str]] = Field(
        None,
        description='Specifies Application M(s) compatible with the Application described in this version of the Application Descriptor.',
    )
    swImageDesc: Optional[List[SwImageDesc]] = Field(
        None,
        description='Defines descriptors of software images to be used by the Application.',
    )
    vdu: Optional[List[VDU]] = Field(
        None, description='VDUs related to this Application Descriptor.'
    )
    deploymentFlavour: Optional[List[DeploymentFlavour]] = Field(
        None,
        description='Describes specific DF(s) of a Application with specific requirements for capacity and performance.',
    )
    appExtCpd: Optional[List[AppExtCpd]] = Field(
        None,
        description='Describes external interface(s) exposed by this Application enabling connection with a VL.',
    )
    virtualCpd: Optional[List[VirtualCpd]] = Field(
        None,
        description='Describes a virtual connection point allowing to access a set of Application Component instances (based on their respective VDUs)\n',
    )
